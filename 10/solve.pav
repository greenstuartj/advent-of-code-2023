include "../base/base.pav"

object Space
object Start
object Vert
object Horiz
object LowLeft
object LowRight
object TopLeft
object TopRight
object Blank

function eq(x : Space,    y : Space)    return true  end
function eq(x : Start,    y : Start)    return true  end
function eq(x : Vert,     y : Vert)     return true  end
function eq(x : Horiz,    y : Horiz)    return true  end
function eq(x : LowLeft,  y : LowLeft)  return true  end
function eq(x : LowRight, y : LowRight) return true  end
function eq(x : TopLeft,  y : TopLeft)  return true  end
function eq(x : TopRight, y : TopRight) return true  end
function eq(x : Blank,    y : Blank)    return true  end
function eq(x,            y)            return false end

record Cell
  type
  coord : Coord
end

record Maze
  rows
end

function get(m : Maze, c : Coord)
  return get(get(m.rows, c.row), c.col)
end

object Up
object Down
object Left
object Right

function move(d : Up,    x : Coord) return Coord(x.row-1, x.col)   end
function move(d : Down,  x : Coord) return Coord(x.row+1, x.col)   end
function move(d : Left,  x : Coord) return Coord(x.row,   x.col-1) end
function move(d : Right, x : Coord) return Coord(x.row,   x.col+1) end

function moves(x : Start)    return Stack(List(Down, Right)) end
function moves(x : Vert)     return Stack(List(Up,   Down))  end
function moves(x : Horiz)    return Stack(List(Left, Right)) end
function moves(x : LowLeft)  return Stack(List(Up,   Right)) end
function moves(x : LowRight) return Stack(List(Up,   Left))  end
function moves(x : TopLeft)  return Stack(List(Down, Right)) end
function moves(x : TopRight) return Stack(List(Down, Left))  end

var cells = Dict(List(Pair('.', Space),
                      Pair('S', Start),
                      Pair('|', Vert),
                      Pair('-', Horiz),
                      Pair('L', LowLeft),
                      Pair('J', LowRight),
                      Pair('F', TopLeft),
                      Pair('7', TopRight)))

var lines = split(read_file(get(_args(), 2)), "\n")

var blank = Cell(Blank, Coord(0, 0))

var start = Coord(0, 0)
var rows = List()

for row = 0, row < len(lines), row += 1 do
  var temp = List()
  var c_row = get(lines, row)
  for col = 0, col < len(c_row), col += 1 do
    var cell = get(cells, get(c_row, col))
    if cell == Start then
      start = Coord(row+1, col+1)
    end
    append(temp, Cell(cell, Coord(row+1, col+1)))
  end
  append(rows, List(blank) + temp + List(blank))
end

var blank_row = List(repeat(blank, len(get(rows, 0))))
var maze = Maze(blank_row + rows + blank_row)

var path       = Stack(List(start, start))
var path_moves = Stack(List(moves(Start)))
var directions = Stack()
var loop_set   = Set(List(start))

function make_move()
  var current_position = pop(path)
  var move_option = pop(top(path_moves))
  var next_position = move(move_option, current_position)
  if next_position == top(path) then
    move_option   = pop(top(path_moves))
    next_position = move(move_option, current_position)
  end
  push(path, current_position)
  push(path, next_position)
  push(path_moves, moves(get(maze, next_position).type))
  push(directions, move_option)
  insert(loop_set, current_position)
end

make_move()
while top(path) != start do
  make_move()
end

println(len(path)/2)

function neighbours(m : Maze, c : Cell)
  var result = List()
  for i = -1, i < 2, i += 1 do
    for j = -1, j < 2, j += 1 do
      append(result, get(m, Coord(c.coord.row+i, c.coord.col+j)))
    end
  end
  return result
end

function flood(m : Maze, c : Cell, s : Set)
  if contains(loop_set, c.coord) | contains(s, c.coord) then
    return
  end
  insert(s, c.coord)
  if c.type == Blank then
    return
  end
  foreach(neighbours(m, c), function(nb)
    flood(m, nb, s)
  end)
end

function flood(m : Maze, l : Coord, d, s1 : Set, s2 : Set)
  dispatch (get(m, l).type, d)
      (t : Vert,    d : Down)  flood(m, get(m, move(Left,  l)), s1)
                               flood(m, get(m, move(Right, l)), s2)
  and (t : Vert,    d : Up)    flood(m, get(m, move(Right, l)), s1)
                               flood(m, get(m, move(Left,  l)), s2)
  and (t : Horiz,   d : Left)  flood(m, get(m, move(Up,    l)), s1)
                               flood(m, get(m, move(Down,  l)), s2)
  and (t : Horiz,   d : Right) flood(m, get(m, move(Down,  l)), s1)
                               flood(m, get(m, move(Up,    l)), s2)
  and (t : LowLeft, d : Down)  flood(m, get(m, move(Left,  l)), s1)
                               flood(m, get(m, move(Down,  l)), s1)
  and (t : LowLeft, d : Right) flood(m, get(m, move(Left,  l)), s2)
                               flood(m, get(m, move(Down,  l)), s2)
  and (t : TopLeft, d : Up)    flood(m, get(m, move(Left,  l)), s2)
                               flood(m, get(m, move(Up,    l)), s2)
  and (t : TopLeft, d : Right) flood(m, get(m, move(Left,  l)), s1)
                               flood(m, get(m, move(Down,  l)), s1)
  and (t : TopRight, d : Up)   flood(m, get(m, move(Right, l)), s1)
                               flood(m, get(m, move(Up,    l)), s1)
  and (t : TopRight, d : Left) flood(m, get(m, move(Right, l)), s2)
                               flood(m, get(m, move(Up,    l)), s2)
  and (t : LowRight, d : Down) flood(m, get(m, move(Right, l)), s2)
                               flood(m, get(m, move(Down,  l)), s2)
  and (t : LowRight, d : Left) flood(m, get(m, move(Right, l)), s1)
                               flood(m, get(m, move(Down,  l)), s1)
  and (t,            d)
  end
end

var s1 = Set()
var s2 = Set()

while !is_empty(directions) do
  var c = pop(path)
  var d = pop(directions)
  flood(maze, c, d, s1, s2)
end

if contains(s1, Coord(0,0)) then
  println(len(s2))
else
  println(len(s1))
end
