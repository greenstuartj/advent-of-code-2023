include "../base/base.pav"

object Space
object Round
object Cube

function repr(:Space) return "." end
function repr(:Round) return "O" end
function repr(:Cube)  return "#" end

function eq(:Space, :Space) return true end
function eq(:Round, :Round) return true end
function eq(:Cube , :Cube)  return true end
function eq(x, y) return false end

function step(d)
  var next = List()
  for i = 0, i < len(d), i += 1 do
    var row = get(d, i)
    var temp = List()
    for j = 0, j < len(row), j += 1 do
      dispatch (get(row, j))
        (:Round)
          var next_row = get(next, i-1)
          dispatch (get(next_row, j))
            (:Space)
              set(next_row, j, Round)
              append(temp, Space)
          and
            (x)
              append(temp, Round)
          end
      and
        (x)
          append(temp, x)
      end
    end
    append(next, temp)
  end
  return next
end

function fixed_point(v, f : Function)
  var before = v
  var after = f(v)
  while after != before do
    before = after
    after = f(after)
  end
  return after
end

function load(d)
  var row_n = len(d)-2
  var result = 0
  for i = 1, i < len(d), i += 1 do
    var row = get(d, i)
    for j = 0, j < len(row), j += 1 do
      dispatch (get(row, j))
        (:Round)
          result += row_n
      and
        (x)
      end
    end
    row_n -= 1
  end
  return result
end

var lines = split(read_file("input.txt"), "\n")

var dish = List(repeat(Cube, 2+len(get(lines, 0))))
for i = 0, i < len(lines), i += 1 do
  var row = get(lines, i)
  var temp = List(Cube)
  for j = 0, j < len(row), j += 1 do
    var c = get(row, j)
    if c == '.' then
      append(temp, Space)
    elif c == 'O' then
      append(temp, Round)
    else
      append(temp, Cube)
    end
  end
  append(temp, Cube)
  append(dish, temp)
end
append(dish, repeat(Cube, len(get(dish, 0))))

println(load(fixed_point(dish, step)))
